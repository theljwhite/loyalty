// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

model LoyaltyProgram {
    id                String                   @id @unique @default(cuid())
    address           String                   @unique
    creatorId         String
    creator           User                     @relation(fields: [creatorId], references: [id])
    name              String
    description       String?
    objectives        Objective[]
    tiers             Tier[]
    state             ProgramState
    chain             String
    chainId           Int
    tiersActive       Boolean                  @default(false)
    programStart      DateTime
    programEnd        DateTime
    rewardType        RewardType
    escrowAddress     String?                  @unique
    escrow            Escrow?
    version           String                   @default("0.03")
    createdAt         DateTime                 @default(now())
    updatedAt         DateTime                 @updatedAt
    contractEvents    Boolean?
    wallets           Wallet[]
    walletSetId       String?                  @unique
    analyticsSummary  ProgramAnalyticsSummary?
    progressionEvents ProgressionEvent[]
    rewardEvents      RewardEvent[]
}

model Escrow {
    id               String         @id @default(cuid())
    address          String         @unique
    rewardAddress    String         @default("")
    senderAddress    String         @default("")
    creatorId        String
    creator          User           @relation(fields: [creatorId], references: [id])
    escrowType       EscrowType
    state            EscrowState
    depositKey       String         @default(cuid())
    depositEndDate   DateTime?
    isSenderApproved Boolean        @default(false)
    isRewardApproved Boolean        @default(false)
    isDepositKeySet  Boolean        @default(false)
    loyaltyAddress   String         @unique
    loyalty          LoyaltyProgram @relation(fields: [loyaltyAddress], references: [address]) //make this loyaltyProgram
    createdAt        DateTime       @default(now())
    updatedAt        DateTime       @updatedAt
}

model Objective {
    id               String          @id @default(cuid())
    indexInContract  Int
    title            String
    reward           Int
    authority        Authority
    loyaltyProgram   LoyaltyProgram? @relation(fields: [loyaltyProgramId], references: [id])
    loyaltyProgramId String?
}

model Tier {
    id               String          @id @default(cuid())
    indexInContract  Int
    name             String
    rewardsRequired  Int
    loyaltyProgram   LoyaltyProgram? @relation(fields: [loyaltyProgramId], references: [id])
    loyaltyProgramId String?
}

model Wallet {
    refId       String         @unique @default(uuid())
    walletId    String         @unique
    externalId  String         @unique
    walletSetId String
    walletSet   LoyaltyProgram @relation(fields: [walletSetId], references: [walletSetId])
    address     String
    isAssigned  Boolean
}

// Necessary for Next auth
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model Session {
    id                         String   @id @default(cuid())
    sessionToken               String   @unique
    provider_providerAccountId String?  @unique
    userId                     String
    expires                    DateTime
    user                       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id              String           @id @unique @default(cuid())
    address         String?          @unique
    name            String?
    email           String?          @unique
    image           String?
    emailVerified   DateTime?
    loyaltyPrograms LoyaltyProgram[]
    escrowContracts Escrow[]
    accounts        Account[]
    sessions        Session[]
    role            UserRole         @default(User)
    apiKey          String?          @unique //this may be temporary and moved elsewhere, considering best security practices (even tho this is stored right now as a b64'd hash)
    apiKeyUpdatedAt DateTime?
    rsaPublicKey    String?          @unique //this may be temporary and moved elsewhere, considering best security practices
    es              String?          @unique //this may be temporary and moved elsewhere, considering best security practices (even tho this is stored right now as a hash that is also encrypted and b64'd lols)
    esUpdatedAt     DateTime?
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

//TEMP - below may be moved to a diff data source.
//but provides an outline at least for optional aggregate analytics
//since these types of things are expensive on-chain.
//the smart contracts provide lookup for stats by address,
//but in order to aggregate data, the contracts emit events which...
//...are listened for off-chain and can be stored off-chain here (or elsewhere) 
model ProgressionEvent {
    id              String         @id @default(cuid())
    eventName       EventName
    loyaltyAddress  String
    transactionHash String
    userAddress     String
    objectiveIndex  Int?
    timestamp       DateTime
    pointsChange    Int?
    userPointsTotal Int
    loyaltyProgram  LoyaltyProgram @relation(fields: [loyaltyAddress], references: [address], onDelete: Cascade)
}

model RewardEvent {
    id              String         @id @default(cuid())
    eventName       EventName
    loyaltyAddress  String
    transactionHash String
    userAddress     String
    timestamp       DateTime
    tokenId         Int?
    tokenAmount     Int?
    erc20Amount     BigInt?
    escrowType      EscrowType
    loyaltyProgram  LoyaltyProgram @relation(fields: [loyaltyAddress], references: [address], onDelete: Cascade)
}

model ProgramAnalyticsSummary {
    id                       String         @id @default(cuid())
    loyaltyAddress           String         @unique
    totalObjectivesCompleted Int            @default(0)
    totalUniqueUsers         Int            @default(0)
    totalUniqueRewarded      Int            @default(0)
    totalTokensWithdrawn     Int            @default(0)
    totalERC20Withdrawn      BigInt         @default(0)
    totalUnclaimedTokens     Int            @default(0)
    totalUnclaimedERC20      BigInt         @default(0)
    avgUserWithdrawTime      Int            @default(0)
    dailyAverageUsers        Decimal        @default(0)
    monthlyAverageUsers      Decimal        @default(0)
    returningUsers           Int            @default(0)
    createdAt                DateTime       @default(now())
    updatedAt                DateTime       @updatedAt
    loyaltyProgram           LoyaltyProgram @relation(fields: [loyaltyAddress], references: [address], onDelete: Cascade)
}

enum EventName {
    ObjectiveCompleted
    PointsUpdate
    ERC20Rewarded
    ERC721Rewarded
    ERC1155Rewarded
    UserWithdraw
}

enum UserRole {
    User
    Creator
    Team
}

enum RewardType {
    Points
    ERC20
    ERC721
    ERC1155
}

enum EscrowType {
    ERC20
    ERC721
    ERC1155
}

enum ProgramState {
    Idle
    AwaitingEscrowSetup
    Active
    Completed
    Canceled
}

enum EscrowState {
    Idle
    AwaitingEscrowApprovals
    DepositPeriod
    AwaitingEscrowSettings
    InIssuance
    Completed
    Frozen
    Canceled
}

enum Authority {
    USER
    CREATOR
}
